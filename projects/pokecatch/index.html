<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> PokeCatch | Nayesha Gandotra </title> <meta name="author" content="Nayesha Gandotra"> <meta name="description" content="Real Time tracking automated arcade game that plays itself"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://nayeshagandotra.github.io/projects/pokecatch/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Nayesha</span> Gandotra </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <article> <h1 style="font-size: 1.5em; font-weight: bold;">PokeCatch: A User Friendly Real Time Arcade Game</h1> <p style="margin-top: 1.5em;"> Often in microprocessor based mechanical systems, it is desirable- if not necessary- to have real time sensor data to inform actuator motion. However, if the system consists of too many peripherals, a traditional implementation can result in a significant time delay between data acquisition and peripheral control due to the sequential manner in which microprocessor logic is executed. In this project, we sought to eliminate this delay by implementing prioritized timer interrupts firing at a constant calculated frequency, which allowed us to realize fine control of microprocessor level multitasking, hence resulting in measurably improved real time sensor data acquisition. We believe the technique of using multitasking to drive better real time implementations has pertinent uses in developing robot-human teams and adaptive robots that can use real time information to inform robustness to disturbance. <br><br> This project was a part of ME135, the Design of Microprocessor Based mechanical Systems class, and ME102B, the senior design project class- both of which have a joint showcase at the end of the semester where children from bay area high schools are invited to browse college level engineering projects. Knowing this, we decided to create a fun automated arcade game with an associated user-friendly interface in order to educate the participating children about the real world use of microelectronics. The “PokeCatch” game consisted of a moving target- pokemon- on a timing belt actuated by a DC motor, as well as a potentiometer controlled projectile system which shot a ping pong ball. The game additionally supported two modes- “human” and “robot”. In the robot mode, the game would predict target location based on real time magnetic encoder data and calculate an optimized ball trajectory to perfectly capture the moving target. Thus by comparing the human and robot mode implementations we were able to demonstrate the benefits of using multitasking to inform better real time actuation. </p> <h2 style="font-size: 1.2em; font-style: italic; margin-top: 1.5em;">Infrastructure Used:</h2> <p style="margin-top: 0.3em;"> Recognizing that most well-documented open source microcontrollers don’t support multitasking, we opted to use the PSoC6 BLE microcontroller and the associated embedded C based ModusToolbox IDE to implement our project. Details about the same can be found on the Cypress Semiconductors Website. </p> <h2 style="font-size: 1.2em; font-style: italic; margin-top: 1.5em;">Implementation</h2> <h3 style="font-size: 1.05em; font-style: italic; margin-top: 0.3em;">Tracking System</h3> <p style="margin-top: 0.3em;"> The tracking system consisted of a timing belt, two pulleys, and a DC motor with an encoder. We decided on a preliminary 1.5m as the length of the tracking system, and 0.5m/s as the speed of the target as it moved across the track. Based on availability, we chose 3cm diameter timing belt pulleys, and planned on fixing the target to the timing belt using an appropriate magnet. Based on these figures, we found the required torque output from the DC motor as 2.5 microN/meter. </p> <p style="margin-top: 0.3em;"> The maximum input voltage was set to 12 V. Based on our torque requirements we chose the 25GA-370 DC 12V Micro Gear Box Motor. Once the Motor was selected, we design mounts and the base for the system to rest on and went into fabrication to test our motor outputs. <br><br> To drive the motor we used the ModusToolbox Hardware Abstraction Layer Library (HAL) to initialize multiple PWM signals. One was used as a “get data” timer interrupt, which polled the GPIO pin connected to the motor encoder every 25 milliseconds. Another PWM signal was sent to the DC motor to drive the clockwise and counter clockwise depending on when the encoder count indicated the end of the track. From initial encoder readings, we were able to create a map between the encoder count and the track. Finally, we simplified all of this calculation to represent a real time visualisation of the target on the tracking system on the user facing GUI: </p> <div class="row text-center"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/pokecatch/pc1-480.webp 480w,/assets/img/pokecatch/pc1-800.webp 800w,/assets/img/pokecatch/pc1-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/pokecatch/pc1.png" class="img-fluid rounded" width="100%%" height="auto" title="Figure 1" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption text-center">Figure 1: (Above)Unedited and (Below) User facing GUI with start, stop, and human functionalities</div> <div class="row text-center"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/pokecatch/pc2-480.webp 480w,/assets/img/pokecatch/pc2-800.webp 800w,/assets/img/pokecatch/pc2-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/pokecatch/pc2.png" class="img-fluid rounded" width="100%%" height="auto" title="Figure 2" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 style="font-size: 1.2em; font-style: italic; margin-top: 1.5em;">Use of Multitasking: </h2> <p style="margin-top: 0.3em;"> On the PSoC6 side, we implemented three timer interrupts to complete the functionalities we required. These were the “get data” interrupt, the “shoot” interrupt, and the “reset” interrupt. Because acquiring encoder data was critical to all subsequent tasks, we placed the get data interrupt at the highest priority in order to collect real time data and store it in an appropriate buffer. This ensured that there would be no data lost during the functioning of the system, and the 100% accurate shooting of the target proved that hypothesis. We placed the “shoot” interrupt at the second priority, because after data acquisition the next critical task was launching the ball automatically in the robot mode. Knowing the fact that the system takes around 3 seconds after sending the “shoot” command to launch the ball, as well as by using simple projectile motion to model the path of the ball, we calculated the exact spots where the trigger command would be sent. We then found the optimum potentiometer values to map to the servo that would take the projectile system to where it needed to be to hit the Pokemon. The result of that was that every time the pokemon crossed a certain location along the track, the timer interrupt would call the “shoot()” function, which would make the launcher shoot a ball that hit the pokemon. Finally, we implemented the reset interrupt at the lowest priority to rewind the spring every five seconds. This interrupt was triggered every time the shoot button was triggered, and functioned as a five second countdown before shooting could be commanded again. The interrupt flag was set to false within the “stop game” function so that the timer would reset every time the game started. It was implemented to prevent the mechanical system from choking due to too many shoot commands sent its way. </p> <div class="row text-center"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/pokecatch/pc3-480.webp 480w,/assets/img/pokecatch/pc3-800.webp 800w,/assets/img/pokecatch/pc3-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/pokecatch/pc3.png" class="img-fluid rounded" width="100%%" height="auto" title="Figure 3" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p style="margin-top: 0.3em;"> There were two more interrupts that we had used to enable multitasking. We configured two GPIO interrupts to shoot the ping pong ball when in “human” mode and another to detect if the Pokemon had been shot successfully. The GPIO interrupt that shot the ping pong ball was triggered during the rising edge of a button. The interrupt handler checked if “human” mode was on and, if “human” mode was on, it would shoot the ping pong ball and set the has_shot flag to true. This flag was used in conjunction with the timer interrupt used to “reset” the shooter to ensure that the user had enough time to reload the projectile system. <br><br> The GPIO interrupt that detected if the Pokemon had been shot successfully used data from a laser sensor that set a pin to high when the laser had detected that the Pokemon was off of the tracking system. This would update the user’s score in the game. Both of these interrupts were set at the lowest priorities since they weren’t considered as “time critical” as other tasks. </p> <h2 style="font-size: 1.2em; font-style: italic; margin-top: 1.5em;">Results and Conclusion </h2> <p style="margin-top: 0.3em;"> Upon visual observation of the GUI plotting of target location, we found virtually no delay between the mapping of the target and the target movement in real life thanks to the prioritization of data acquisition and transmission. Additionally, the implementation of a buffer enabled us to store all past sensor values, which ensured that no significant point would be lost which could result in erroneous shooting by the launcher. Thus, by observing the multitasking system we can confidently advocate the use of nested interrupts to drive faster real time tracking of live data. At the end of it all, our game was highly enjoyed by the spectators, who set up a “high score” chart to compare human performance to robot performance. We are glad to have been able to work on a fun application of a highly important microcontroller concept and gain a depth of knowledge on controlling microcontroller based mechanical systems through this project. </p> <h2 style="font-size: 1.2em; font-style: italic; margin-top: 1.5em;">Contributors </h2> <p style="margin-top: 0.3em;"> Brittany Navailles and Nayesha Gandotra </p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Nayesha Gandotra. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>